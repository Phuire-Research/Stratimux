/*<$
For the asynchronous graph programming framework Stratimux, define the Ownership model file.
This file will dictate functionality used within the Ownership Concept to engage in its functionality.
$>*/
/*<#*/
/* eslint-disable max-depth */
import { OwnershipState, ownershipName } from '../concepts/ownership/ownership.concept';
import { Concepts } from './concept/concept.type';
import { selectState } from './selector/selector';
import { getMuxiumState } from './muxium/muxiumHelpers';
import { Action } from './action/action.type';
import { ActionNode, ActionStrategy } from './action/strategy/actionStrategy.type';
import { areSemaphoresEqual } from './action/actionSemaphore';

export type OwnershipLedger = Map<string, OwnershipTicket[]>;

export type OwnershipTicket = {
  ticket: string;
  expiration: number;
  created: number; // Timestamp when ticket was created for fair FIFO ordering
}

export type OwnershipTicketStub = {
  key: string;
  ticket: string;
}

// Future Note: Higher-Order Ledger for Bi-Directional and Multi-Dimensional Systems
// In higher-order systems, orphaned nodes maintain relationships through general categories,
// preventing information loss. This contrasts with uni-directional systems where orphaned
// nodes lose their contextual relationships. This ledger will enable:
// - Bi-directional traversal (child ‚Üí parent, parent ‚Üí child)
// - Bi-directional relationships beyond uni-directional trees
// - Automatic orphan recategorization to prevent context loss
// Stop Gap Measure pending Future Development of Higher-Order Strong Fast Systems
export type HigherOrderLedger = Record<string, unknown>; // Placeholder for future implementation

// UniDirectional Ledger for current filesystem/object paradigm
// Tracks uni-directional ownership where parent paths block descendant paths
// Reflects the reality that both filesystems and JavaScript objects follow
// uni-directional relationships where nodes can become orphaned
export type Wrung = Record<string, unknown>; // Set as KeyWrung
export type KeyWrung = Record<string, {
  wrung: Wrung;
  registeredKeys: string[];
  stake?: string; // Path that holds stake at this END WRUNG only
}>; // Bi-directional associative structure with stake tracking

export type UniDirectionalLedger = {
  pathSegments: Map<string, Set<string>>; // Maps each segment to full paths containing it
  keyWrungs: Map<string, KeyWrung>; // Maps full paths to their wrungs
  depthIndex: Map<number, Set<string>>; // Maps depth levels to paths at that depth
};

export const createOwnershipLedger = (): OwnershipLedger => new Map<string, OwnershipTicket[]>();

export const createUniDirectionalLedger = (): UniDirectionalLedger => ({
  pathSegments: new Map(),
  keyWrungs: new Map(),
  depthIndex: new Map()
});

// Helper functions for recursive KeyWrung manipulation
export const createKeyWrung = (key: string): KeyWrung => {
  const segments = key.split('.');
  const buildWrung = (index: number): KeyWrung => {
    if (index >= segments.length) {
      return {};
    }
    const segment = segments[index];
    return {
      [segment]: {
        wrung: buildWrung(index + 1),
        registeredKeys: [key]
      }
    };
  };
  return buildWrung(0);
};

// Add a path to an existing KeyWrung or create new branches
export const addToKeyWrung = (wrung: KeyWrung, segments: string[], fullPath: string, index = 0, currentPath = ''): void => {
  if (index >= segments.length) {
    return; // Reached the end
  }

  const segment = segments[index];
  const newPath = currentPath ? `${currentPath}.${segment}` : segment;

  if (!wrung[segment]) {
    wrung[segment] = {
      wrung: {},
      registeredKeys: []
    };
  }

  // Add the full path to registeredKeys if not already there
  if (!wrung[segment].registeredKeys.includes(fullPath)) {
    wrung[segment].registeredKeys.push(fullPath);
  }

  addToKeyWrung(wrung[segment].wrung as KeyWrung, segments, fullPath, index + 1, newPath);
};

// Remove a path from a KeyWrung in a single forward pass
// Returns true if the branch was completely removed (no other keys)
export const removeFromKeyWrung = (wrung: KeyWrung, segments: string[], fullPath: string, index = 0): boolean => {
  if (index >= segments.length - 1) {
    // At the last segment
    const lastSegment = segments[index];
    if (wrung[lastSegment]) {
      // Remove the fullPath from registeredKeys
      const node = wrung[lastSegment];
      const pathIndex = node.registeredKeys.indexOf(fullPath);
      if (pathIndex > -1) {
        node.registeredKeys.splice(pathIndex, 1);
      }

      // Check if there are other keys at this level or registered paths
      if (Object.keys(node.wrung).length === 0 && node.registeredKeys.length === 0) {
        // No other keys or paths, remove this branch
        delete wrung[lastSegment];
        return true;
      }
      // Has other keys or paths, keep the branch
      return false;
    }
    return false;
  }

  const segment = segments[index];
  if (wrung[segment]) {
    const node = wrung[segment];
    const wasRemoved = removeFromKeyWrung(node.wrung as KeyWrung, segments, fullPath, index + 1);

    // Remove fullPath from this level's registeredKeys
    const pathIndex = node.registeredKeys.indexOf(fullPath);
    if (pathIndex > -1) {
      node.registeredKeys.splice(pathIndex, 1);
    }

    if (wasRemoved && Object.keys(node.wrung).length === 0 && node.registeredKeys.length === 0) {
      // Child was removed and no other children exist or paths registered
      delete wrung[segment];
      return true;
    }
  }
  return false;
};

/**
 * Recalculates stake ownership at a specific wrung based on temporal priority.
 * Stake is only awarded at END wrungs (leaf nodes) to the earliest creation time.
 */
export const recalculateStakeAtWrung = (
  wrung: KeyWrung,
  wrungPath: string,
  ownershipLedger: OwnershipLedger
): void => {
  // Iterate through all nodes at this wrung level
  for (const [segment, node] of Object.entries(wrung)) {
    const currentPath = wrungPath ? `${wrungPath}.${segment}` : segment;

    // Check if this is an end wrung (has registered keys)
    const hasRegisteredKeys = node.registeredKeys.length > 0;
    const hasDeepWrungs = Object.keys(node.wrung).length > 0;

    if (hasRegisteredKeys) {
      // Only award stake at END wrungs for paths that terminate here
      // Filter to only keys that END at this level
      const endingKeys = node.registeredKeys.filter(key => {
        // A key ends here if it matches the current path exactly
        return key === currentPath;
      });

      if (endingKeys.length > 0) {
        // Find the earliest creation time among keys ending at this wrung
        let earliestPath: string | undefined;
        let earliestCreation = Infinity;

        for (const registeredKey of endingKeys) {
          const tickets = ownershipLedger.get(registeredKey);
          if (tickets && tickets.length > 0) {
            const firstTicket = tickets[0];
            const creationTime = firstTicket.created || firstTicket.expiration;

            if (creationTime < earliestCreation) {
              earliestCreation = creationTime;
              earliestPath = registeredKey;
            }
          }
        }

        // Award stake to the earliest path (or clear if no tickets remain)
        node.stake = earliestPath;

        // Stake has been set to earliestPath or undefined
      } else {
        // This is not an end wrung for any registered keys, clear stake
        node.stake = undefined;
      }
    }

    // Recursively process child wrungs
    if (hasDeepWrungs) {
      recalculateStakeAtWrung(node.wrung as KeyWrung, currentPath, ownershipLedger);
    }
  }
};

/**
 * Recalculates all stakes in the entire KeyWrung tree.
 * Called after clearing stubs to reassign ownership based on temporal priority.
 */
export const recalculateAllStakes = (
  ledger: UniDirectionalLedger,
  ownershipLedger: OwnershipLedger
): void => {
  const originWrungSet = ledger.pathSegments.get('origin');
  if (originWrungSet) {
    try {
      const originWrung = JSON.parse(Array.from(originWrungSet)[0]) as KeyWrung;
      recalculateStakeAtWrung(originWrung, '', ownershipLedger);
      // Save the updated wrung back
      ledger.pathSegments.set('origin', new Set([JSON.stringify(originWrung)]));
    } catch (error) {
      // Error recalculating stakes
    }
  }
};

// Add a path to the uni-directional ledger
export const addToUniDirectionalLedger = (
  ledger: UniDirectionalLedger,
  key: string,
  ownershipLedger?: OwnershipLedger
): void => {
  // Create individual wrung for this key
  const wrung = createKeyWrung(key);
  ledger.keyWrungs.set(key, wrung);

  // Add to origin wrung (stored in pathSegments with 'origin' key)
  let originWrung = ledger.pathSegments.get('origin');
  if (!originWrung) {
    originWrung = new Set([JSON.stringify({})]);
    ledger.pathSegments.set('origin', originWrung);
  }

  const origin = JSON.parse(Array.from(originWrung)[0]) as KeyWrung;
  addToKeyWrung(origin, key.split('.'), key);

  // After adding, recalculate stakes if we have the ownership ledger
  if (ownershipLedger) {
    recalculateStakeAtWrung(origin, '', ownershipLedger);
  }

  ledger.pathSegments.set('origin', new Set([JSON.stringify(origin)]));

  // Track depth for optimization
  const depth = key.split('.').length;
  if (!ledger.depthIndex.has(depth)) {
    ledger.depthIndex.set(depth, new Set());
  }
  ledger.depthIndex.get(depth)?.add(key);
};

// Check if a path has an owned ancestor using KeyWrung
export const hasOwnedAncestor = (
  key: string,
  ownershipLedger: OwnershipLedger,
  uniDirectionalLedger?: UniDirectionalLedger
): boolean => {
  const segments = key.split('.');

  // If we have a uniDirectionalLedger, use KeyWrung traversal
  if (uniDirectionalLedger) {
    const originWrungSet = uniDirectionalLedger.pathSegments.get('origin');
    if (originWrungSet) {
      try {
        const originWrung = JSON.parse(Array.from(originWrungSet)[0]) as KeyWrung;
        let currentWrung: KeyWrung = originWrung;
        let currentPath = '';

        // Traverse the KeyWrung tree checking each ancestor
        for (let i = 0; i < segments.length - 1; i++) {
          const segment = segments[i];
          currentPath = i === 0 ? segment : `${currentPath}.${segment}`;

          // Check if this path has tickets in the ownershipLedger
          const tickets = ownershipLedger.get(currentPath);
          if (tickets && tickets.length > 0) {
            console.log(`   üö´ Ancestor "${currentPath}" owns (via KeyWrung), blocking "${key}"`);
            return true;
          }

          // Move to next level in KeyWrung tree
          if (currentWrung[segment] && currentWrung[segment].wrung) {
            currentWrung = currentWrung[segment].wrung as KeyWrung;
          } else {
            // Path doesn't exist in tree, no ancestors can own it
            break;
          }
        }
      } catch (error) {
        console.log('   ‚ö†Ô∏è KeyWrung parse error, falling back to direct check');
      }
    }
  }

  // Fallback for when no uniDirectionalLedger
  let currentPath = '';
  for (let i = 0; i < segments.length - 1; i++) {
    currentPath = i === 0 ? segments[0] : `${currentPath}.${segments[i]}`;
    const tickets = ownershipLedger.get(currentPath);
    if (tickets && tickets.length > 0) {
      console.log(`   üö´ Ancestor "${currentPath}" owns, blocking "${key}"`);
      return true;
    }
  }
  return false;
};

// Check if a path has owned descendants using KeyWrung
export const hasOwnedDescendants = (
  key: string,
  ledger: UniDirectionalLedger,
  ownershipLedger: OwnershipLedger
): boolean => {
  // Use KeyWrung to find descendants
  const originWrungSet = ledger.pathSegments.get('origin');
  if (originWrungSet) {
    try {
      const originWrung = JSON.parse(Array.from(originWrungSet)[0]) as KeyWrung;
      const segments = key.split('.');
      let currentWrung: KeyWrung = originWrung;

      // Navigate to the node for this key
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        if (currentWrung[segment]) {
          if (i === segments.length - 1) {
            // We're at the target node, check its registeredKeys for descendants
            const node = currentWrung[segment];

            // Check all registered paths under this node
            for (const registeredPath of node.registeredKeys) {
              // Skip if it's the key itself
              if (registeredPath !== key && registeredPath.startsWith(key + '.')) {
                // Check if this descendant has tickets
                const tickets = ownershipLedger.get(registeredPath);
                if (tickets && tickets.length > 0) {
                  console.log(`   üö´ Descendant "${registeredPath}" owns (via KeyWrung), blocking "${key}"`);
                  return true;
                }
              }
            }

            // Also recursively check the wrung for any descendants
            const checkDescendantWrung = (wrung: KeyWrung, basePath: string): boolean => {
              for (const [childSegment, childNode] of Object.entries(wrung)) {
                const childPath = `${basePath}.${childSegment}`;

                // Check if this path has tickets
                const tickets = ownershipLedger.get(childPath);
                if (tickets && tickets.length > 0) {
                  console.log(`   üö´ Descendant "${childPath}" owns (via KeyWrung), blocking "${key}"`);
                  return true;
                }

                // Recursively check deeper descendants
                if (childNode.wrung && Object.keys(childNode.wrung).length > 0) {
                  if (checkDescendantWrung(childNode.wrung as KeyWrung, childPath)) {
                    return true;
                  }
                }
              }
              return false;
            };

            // Check all descendants in the wrung
            if (node.wrung && Object.keys(node.wrung).length > 0) {
              return checkDescendantWrung(node.wrung as KeyWrung, key);
            }
          } else {
            currentWrung = currentWrung[segment].wrung as KeyWrung;
          }
        } else {
          // Path doesn't exist, no descendants
          return false;
        }
      }
    } catch (error) {
      // KeyWrung parse error in hasOwnedDescendants
    }
  }

  // Fallback: direct string prefix check
  const keyPrefix = key + '.';
  for (const [path, tickets] of ownershipLedger.entries()) {
    if (path.startsWith(keyPrefix) && tickets.length > 0) {
      // Descendant owns, blocking parent
      return true;
    }
  }
  return false;
};

// Check if we can proceed based on stake ownership
// Returns true if we have stake or can claim it at our end wrung
export const checkStakeOwnership = (
  stubKey: string,
  stubTicket: string,
  ownershipLedger: OwnershipLedger,
  uniDirectionalLedger: UniDirectionalLedger
): boolean => {
  // Get origin wrung
  const originWrungSet = uniDirectionalLedger.pathSegments.get('origin');
  if (!originWrungSet) {
    return true; // No wrung, we can proceed
  }

  try {
    const originWrung = JSON.parse(Array.from(originWrungSet)[0]) as KeyWrung;
    const segments = stubKey.split('.');
    let currentWrung: KeyWrung = originWrung;

    // Navigate to our end wrung
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];

      if (!currentWrung[segment]) {
        return true; // Path doesn't exist, can proceed
      }

      const node = currentWrung[segment];

      // At our end wrung?
      if (i === segments.length - 1) {
        // Check if we have stake or no one does
        if (!node.stake || node.stake === stubKey) {
          return true; // We have stake or can claim it
        }
        // Blocked by stake holder at end wrung
        return false;
      }

      // Check if someone has stake at an ancestor level that blocks us
      // Only block if the stake holder is on our path (ancestor relationship)
      if (node.stake && node.stake !== stubKey) {
        // Check if the stake holder is our ancestor (we're under them)
        const isUnderStakeHolder = stubKey.startsWith(node.stake + '.');
        // Check if we're the ancestor of the stake holder (they're under us)
        const stakeHolderIsUnderUs = node.stake.startsWith(stubKey + '.');

        if (isUnderStakeHolder || stakeHolderIsUnderUs) {
          // Blocked by uni-directional stake
          return false;
        }
        // Different branches can proceed in parallel
      }

      // Move to next level
      if (node.wrung) {
        currentWrung = node.wrung as KeyWrung;
      }
    }

    return true; // We can proceed
  } catch (error) {
    console.log('   ‚ö†Ô∏è KeyWrung parse error in stake check');
    return true; // On error, allow to proceed
  }
};

// Remove a path from the uni-directional ledger
// Only removes if the ticket is the last in its line in ownershipLedger
export const removeFromUniDirectionalLedger = (
  ledger: UniDirectionalLedger,
  key: string,
  ownershipLedger: OwnershipLedger
): void => {
  // Only proceed if this key has no tickets left in ownership ledger
  const tickets = ownershipLedger.get(key);
  if (tickets && tickets.length > 0) {
    return; // Still has tickets, don't remove from uni-directional ledger
  }

  // Remove individual wrung
  ledger.keyWrungs.delete(key);

  // Remove from origin wrung
  const originWrung = ledger.pathSegments.get('origin');
  if (originWrung) {
    const origin = JSON.parse(Array.from(originWrung)[0]) as KeyWrung;
    removeFromKeyWrung(origin, key.split('.'), key);
    ledger.pathSegments.set('origin', new Set([JSON.stringify(origin)]));
  }

  // Clean up depth index
  const depth = key.split('.').length;
  ledger.depthIndex.get(depth)?.delete(key);

  if (ledger.depthIndex.get(depth)?.size === 0) {
    ledger.depthIndex.delete(depth);
  }
};

const generateUUID = (): string => {
  const randomHex = (): string => {
    return Math.floor(Math.random() * 16).toString(16);
  };

  let uuid = '';
  for (let i = 0; i < 36; i++) {
    if (i === 8 || i === 13 || i === 18 || i === 23) {
      uuid += '-';
    }
    else if (i === 14) {
      uuid += '4';
    }
    else if (i === 19) {
      const variant = Math.floor(Math.random() * 4 + 8).toString(16);
      uuid += variant;
    }
    else {
      uuid += randomHex();
    }
  }
  return uuid;
};

// eslint-disable-next-line complexity
export const ownershipShouldBlock = (concepts: Concepts, action: Action): boolean => {
  // Check if action should be blocked
  let qualityKeys;
  try {
    qualityKeys = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;
  } catch (error) {
    console.log('----');
    console.error(error);
    console.error(JSON.stringify(action.semaphore), action.type, action.origin, Object.keys(concepts));
    console.log('----');
  }
  const actionSelectors = action.keyedSelectors;
  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;
  let shouldBlock = false;
  // Quality Action no Keys, no Strategy - Block by default when quality has selectors
  if (qualityKeys && !actionSelectors && action.strategy === undefined) {
    // Block if ANY quality selector is in use (conservative default for unspecified actions)
    for (let i = 0; i < qualityKeys.length; i++) {
      if (ownershipLedger.has(qualityKeys[i].keys)) {
        shouldBlock = true;
        break;
      }
    }
  // Quality Action WITH Keys, no Strategy - Partial blocking for specific selectors
  } else if (actionSelectors && action.strategy === undefined) {
    // Only block if THIS action's specific selectors conflict OR have owned ancestors
    for (let i = 0; i < actionSelectors.length; i++) {
      const hasAncestor = !ownershipState.higherOrdered &&
        hasOwnedAncestor(actionSelectors[i].keys, ownershipLedger, ownershipState.uniDirectionalLedger);
      const hasDescendant = !ownershipState.higherOrdered &&
        hasOwnedDescendants(actionSelectors[i].keys, ownershipState.uniDirectionalLedger, ownershipLedger);
      if (ownershipLedger.has(actionSelectors[i].keys) || hasAncestor || hasDescendant) {
        shouldBlock = true;
        break;
      }
    }
  // ActionStrategy, with Keys
  } else if (actionSelectors && action.strategy && action.strategy.stubs === undefined) {
    console.log('   Checking ActionStrategy with keys...');
    for (let i = 0; i < actionSelectors.length; i++) {
      const key = actionSelectors[i].keys;
      console.log(`     Checking key: "${key}"`);

      // Check for direct ownership conflict
      const directConflict = ownershipLedger.has(key) && (ownershipLedger.get(key)?.length ?? 0) > 0;

      // For uni-directional, check if any ancestor owns this path
      const hasAncestor = !ownershipState.higherOrdered &&
        hasOwnedAncestor(key, ownershipLedger, ownershipState.uniDirectionalLedger);

      // Also check if any descendants own (bi-directional blocking)
      const hasDescendant = !ownershipState.higherOrdered &&
        hasOwnedDescendants(key, ownershipState.uniDirectionalLedger, ownershipLedger);

      if (directConflict || hasAncestor || hasDescendant) {
        shouldBlock = true;
        if (directConflict) {
          console.log(`       ‚ùå Direct conflict on "${key}"`);
        }
        break;
      }
    }
  }
  if (!shouldBlock && action?.strategy?.stubs) {
    const stubs = action.strategy.stubs;
    let canProceed = true;

    for (let i = 0; i < stubs.length; i++) {
      const stubKey = stubs[i].key;
      const stubTicket = stubs[i].ticket;
      const line = ownershipLedger.get(stubKey);

      // Find our ticket's creation time
      let ourCreationTime = 0;
      if (line) {
        const ourTicketEntry = line.find(t => t.ticket === stubTicket);
        if (ourTicketEntry) {
          ourCreationTime = ourTicketEntry.created || ourTicketEntry.expiration; // Fallback to expiration
        }
      }

      // Step 1: Must be first in our own direct queue
      if (!line || line.length === 0 || line[0].ticket !== stubTicket) {
        console.log(`   ‚è±Ô∏è Not first in direct queue for "${stubKey}"`);
        canProceed = false;
        shouldBlock = true;
        break;
      }

      // Step 2: Check stake ownership via KeyWrung
      if (!ownershipState.higherOrdered && ownershipState.uniDirectionalLedger) {
        const hasStake = checkStakeOwnership(
          stubKey,
          stubTicket,
          ownershipLedger,
          ownershipState.uniDirectionalLedger
        );

        if (!hasStake) {
          canProceed = false;
          shouldBlock = true;
          break;
        }
      }
    }

    if (!shouldBlock && !canProceed) {
      shouldBlock = true;
    }
  }
  // Return blocking decision
  return shouldBlock;
};

export const clearStubs = (concepts: Concepts, strategy: ActionStrategy): Concepts => {
  const newConcepts = concepts;
  const stubs = strategy.stubs;
  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;

  if (stubs) {
    // Track which paths need stake recalculation
    const pathsToRemove: string[] = [];

    // First pass: Remove tickets from ownership ledger
    stubs.forEach(ticketStub => {
      const line = ownershipLedger.get(ticketStub.key);
      if (line) {
        const newLine = [] as OwnershipTicket[];
        for (const stub of line) {
          if (stub.ticket !== ticketStub.ticket) {
            newLine.push(stub);
          }
        }
        if (newLine.length === 0) {
          ownershipLedger.delete(ticketStub.key);
          pathsToRemove.push(ticketStub.key);
        } else {
          ownershipLedger.set(ticketStub.key, newLine);
        }
      }
    });

    // Second pass: Remove from KeyWrung for paths with no tickets
    if (!ownershipState.higherOrdered) {
      pathsToRemove.forEach(path => {
        removeFromUniDirectionalLedger(ownershipState.uniDirectionalLedger, path, ownershipLedger);
      });

      // Third pass: Recalculate stakes for the entire tree
      // This ensures proper stake ownership based on remaining tickets
      recalculateAllStakes(ownershipState.uniDirectionalLedger, ownershipLedger);
    }
  }

  return newConcepts;
};

export const editStubs = (_concepts: Concepts, oldAction: Action, newAction: Action): [Concepts, Action] => {
  const concepts = _concepts;
  const oldStrategy = oldAction.strategy as ActionStrategy;
  const newStrategy = newAction.strategy as ActionStrategy;
  newStrategy.stubs = [];
  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;
  if (oldStrategy.stubs) {
    oldStrategy.stubs.forEach((ticketStub) => {
      const line = ownershipLedger.get(ticketStub.key);
      if (line) {
        for (const stub of line) {
          if (stub.ticket === ticketStub.ticket) {
            stub.expiration = newAction.expiration;
            newStrategy.stubs?.push({
              key: ticketStub.key,
              ticket: stub.ticket
            });
          }
        }
      }
    });
  }
  return [concepts, newAction];
};

export const checkIn = (concepts: Concepts, action: Action): [Concepts, Action] => {
  // Temporary debug logging for Trux test
  if (action.type.includes('trux')) {
    console.log(`\nüìã CHECK IN called for: ${action.type}`);
    console.log(`   Strategy: ${action.strategy?.topic || 'none'}`);
    console.log(`   KeyedSelectors: ${action.keyedSelectors?.length || 0}`);
  }

  const newConcepts = concepts;
  const ownershipState = selectState(newConcepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;
  const strategy = action.strategy;
  if (strategy) {
    strategy.stubs = strategy.stubs ? strategy.stubs : [] as OwnershipTicketStub[];
    action.keyedSelectors?.forEach(keyed => {
      const key = keyed.keys;
      const entry = ownershipLedger.get(key);
      let found = false;
      if (entry && action.strategy?.stubs) {
        for (const ticketStub of entry) {
          for (const stub of action.strategy.stubs) {
            if (ticketStub.ticket === stub.ticket && stub.key === key) {
              found = true;
              break;
            }
          }
          if (found) {
            break;
          }
        }
      }
      if (!found) {
        const expiration = action.expiration;
        const muxiumState = getMuxiumState(concepts);
        const ticket = muxiumState.name + generateUUID();
        const newTicketStub = {
          key,
          ticket,
          expiration
        };
        const newTicket = {
          ticket,
          expiration,
          created: Date.now() // Capture exact creation time for priority
        };
        strategy.stubs?.push(newTicketStub);
        if (entry) {
          entry.push(newTicket);
        } else {
          ownershipLedger.set(key, [newTicket]);
          // Add to uni-directional ledger when first ticket is created
          // Pass ownershipLedger to calculate initial stake
          if (!ownershipState.higherOrdered) {
            addToUniDirectionalLedger(ownershipState.uniDirectionalLedger, key, ownershipLedger);
          }
        }
      }
    });
  }
  return [newConcepts, action];
};

export const isActionReady = (concepts: Concepts, _action: Action): [Concepts, boolean] => {
  const action = _action;
  const stubs = action.strategy?.stubs;
  if (stubs) {
    return stubActionStrategy(concepts, action);
  } else {
    return qualityAction(concepts, action);
  }
};

const stubActionStrategy = (concepts: Concepts, _action: Action): [Concepts, boolean] => {
  const action = _action;
  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;
  const stubs = action.strategy?.stubs as OwnershipTicketStub[];
  let frontOfAllLines = true;
  // let expired = false;
  for (const stub of stubs) {
    const positions = ownershipLedger.get(stub.key);
    if (positions) {
      for (const [i, pos] of positions.entries()) {
        if (i === 0 && pos.ticket === stub.ticket) {
          continue;
        } else {
          frontOfAllLines = false;
          break;
        }
      }
    }
  }
  return [concepts, frontOfAllLines];
};

const qualityAction = (concepts: Concepts, _action: Action): [Concepts, boolean] => {
  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;
  const ownershipLedger = ownershipState.ownershipLedger;
  const action = _action;
  const qualitySelectors = concepts[action.semaphore[0]].qualities[action.semaphore[1]].keyedSelectors;
  let readyToGo = true;

  if (qualitySelectors) {
    for (const selector of qualitySelectors) {
      const key = selector.keys;
      if (ownershipLedger.get(key)) {
        readyToGo = false;
        break;
      }
    }
    return [concepts, readyToGo];
  }
  return [concepts, readyToGo];
};

const areSameDepth = (first: ActionNode, second: ActionNode, count: [number, number]): boolean => {
  const newCount: [number, number] = [
    // Logical Determination: nullActionType
    //  In addition we logically guarantee that action would be set at this point of execution
    (first.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0],
    (second.lastActionNode?.action as Action).semaphore[3] !== 2 ? count[0] + 1 : count[0]
  ];
  if (count[0] !== newCount[0] && count[1] !== newCount[1] && newCount[0] === newCount[1]) {
    return areSameDepth(first.lastActionNode as ActionNode, second.lastActionNode as ActionNode, newCount);
  } else if (count[0] === newCount[0] && count[1] === newCount[1]) {
    return true;
  }
  return false;
};

export const areEqual = (first: Action, second: Action) => {
  let equal = false;
  const firstStrategy = first.strategy;
  const secondStrategy = second.strategy;
  if (firstStrategy === undefined && secondStrategy === undefined) {
    if (areSemaphoresEqual(first, second)) {
      if (first.payload === undefined && second.payload === undefined) {
        equal = true;
      } else {
        equal = JSON.stringify(first.payload) === JSON.stringify(second.payload);
      }
    }
    equal = false;
  } else if (firstStrategy?.topic === secondStrategy?.topic) {
    if (areSemaphoresEqual(first, second)) {
      if (first.payload === undefined && second.payload === undefined) {
        equal = true;
      } else if (JSON.stringify(first.payload) === JSON.stringify(second.payload)) {
        equal = areSameDepth(
          (firstStrategy as ActionStrategy).currentNode,
          (secondStrategy as ActionStrategy).currentNode,
          [0,0]
        );
      }
    }
    equal = false;
  }
  return equal;
};

export const updateAddToPendingActions = (_concepts: Concepts, _action: Action) => {
  let concepts = _concepts;
  const action = _action;
  const ownershipState = selectState(concepts, ownershipName) as OwnershipState;
  const pendingActions = ownershipState.pendingActions;
  const newPendingActions: Action[] = [];
  if (pendingActions.length > 0) {
    for (const pending of pendingActions) {
      const equal = areEqual(action, pending);
      if (equal && pending.keyedSelectors && action.keyedSelectors) {
        let editedAction;
        [concepts, editedAction] = editStubs(concepts, pending, action);
        newPendingActions.push(editedAction);
      } else if (equal) {
        newPendingActions.push(action);
      } else {
        newPendingActions.push(pending);
        newPendingActions.push(action);
      }
    }
    ownershipState.pendingActions = [...newPendingActions];
  } else {
    ownershipState.pendingActions = [action];
  }
  return concepts;
};

export const ownership = {
  createOwnershipLedger,
  ownershipShouldBlock,
  clearStubs,
  editStubs,
  checkIn,
  isActionReady,
  areEqual,
  updateAddToPendingActions
};
/*#>*/