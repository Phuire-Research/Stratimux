## Spatial Ownership - Rough Draft
*Note this in particular is a proof of concept release*
The ownership concept must be explicitly loaded and introduces an additional mode that further transforms the functionality of the axium. Which allows for the locking of values, that other actions or strategies may be dependent upon. And if that strategy, or action with a KeyedSelector has taken a TicketStub of ownership of that value. Any quality or action that would transform such are added to a pendingActions until that block is cleared.

But if a strategy is dependent on that value, that strategy will fail by default. Thus a specific case must be attached to the ActionNode that governs how to handle that specific Case. If so, will be added to a pendingActions that can later be dispatched alongside their TicketStubs and expiration times.

If an action that has a blocking quality specified by a KeySelector, but does not hold a KeyedSelectors on itself. While the ownership ledger holds a ticket of that KeyedSelector, that action will be added to the pendingActions, but only one of that type and properties may exist at once in the actionQue. But will hold that action's place, while updating its expiration to the most recent action's.

This is to allow actions in this system to move off premise and was the inspiration for the design of this system. That such can be a server, web worker, client, etc... To correlate all as an abstract graph computer. That can further be enhanced to used in the within the context of literal graph computers themselves. As we find new means of extending moors law of computational density. This paradigm was designed with specialization of computation in mind. To perform such where best suited. Noting that the internals of a Neural Network are likewise a graph computer of a certain kind and we are ourselves.

While these Actions are off location. Their tickets hold a expiration time that would invalidate said action based upon an optionally set agreement value or otherwise set to a default time. Freeing that lock automatically upon expiration, but only if that System has received an additional action. As the gist of a Unified Turing Machine is that it only runs as long as there are actions in the stream that facilitates the mode. And by running, notices that the time of execution is just beyond some action's expiration. As it is a recursive function.

## How to Jump and not Clear the Ownership Lock
Note that the only mechanism in play that allows for locks to be cleared are the successive actions in a strategy as they enter the ownershipMode. To block an action from clearing their lock, that specific quality, counter to the inspiring strategy design pattern, should not have a method. And instead utilize its reducer to add itself to a que that a principle is subscribed to. Once populated, that principle is in control of that actionStrategy, which may still expire.

This allows for the principle to perform calculations safely on the state of other concepts. Note that this should only be in play, if the intention is to transform that value that others would depend upon. Otherwise a clone of that value suffices and should not have a KeyedSelector upon that action. From here actions may move off premises via whatever mechanism is required to satisfy that calculation.

Originally this approach was created to satisfy the handling of the FileSystem and manipulation of its contents. Summarily such is the best means transforming binary files not written in plain text while STRX exists within the confounds of Typescript. As the paths to those files, act as a key lock within this system.